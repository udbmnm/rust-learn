# Rust 学习笔记

* println! 会自动推导出具体的类型
* rust 里面的“赋值”叫变量绑定更能体现所有权的概念
* 变量在默认不可变，加上 mut 将变量声明为可变
* 可变变量最大的好处就是使用上的灵活性和性能上的提升
* 使用下划线开头忽略未使用的变量
```
fn main() {
    let _x = 5;
    let y = 10; //这里会报错
}
```
* let 可以使用变量解构赋值，和 JS 很像
```
let (a, mut b): (bool,bool) = (true, false);
//在 Rust 1.59 版本后，我们可以在赋值语句的左式中使用元组、切片和结构体模式了
let (a, b, c, d, e);
(a, b) = (1, 2);
// _ 代表匹配一个值，但是我们不关心具体的值是什么，因此没有使用一个变量名而是使用了 _
[c, .., d, _] = [1, 2, 3, 4, 5];
Struct { e, .. } = Struct { e: 5 };
//使用 += 的赋值语句还不支持解构式赋值
```
* 常量不允许使用 mut。常量不仅仅默认不可变，而且自始至终不可变，因为常量在编译完成后，已经确定它的值
* 常量使用 const 关键字而不是 let 关键字来声明，并且值的类型必须标注
* Rust 常量的命名约定是全部字母都使用大写，并使用下划线分隔单词
`const MAX_POINTS: u32 = 100_000;
`
* 变量遮蔽，就是普通的同名变量会覆盖前面的变量名，新变量类型不同也没事，相当于生成全新的变量，旧变量不可访问，局部同名变量只能覆盖局部变量
>这和 mut 变量的使用是不同的，第二个 let 生成了完全不同的新变量，两个变量只是恰好拥有同样的名称，涉及一次内存对象的再分配 ，而 mut 声明的变量，可以修改同一个内存地址上的值，并不会发生内存对象的再分配，性能要更好。

* 避免在浮点数上测试相等性，和 JS 类似的精度问题
```
fn main() {
  // 断言0.1 + 0.2与0.3相等
  assert!(0.1 + 0.2 == 0.3);
}
```

